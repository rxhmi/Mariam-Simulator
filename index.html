<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AGGRESSIVE PISTOL: ULTIMATE 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; color: white; user-select: none; }
        #wrapper { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        canvas { background: #050505; display: block; image-rendering: pixelated; }
        
        /* UI OVERLAYS */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .stat { position: absolute; padding: 10px; background: rgba(255,0,0,0.2); border: 2px solid #f00; font-weight: bold; }
        #score-ui { top: 20px; left: 20px; font-size: 18px; }
        #killfeed { top: 20px; right: 20px; text-align: right; color: #ff4444; }
        #boss-container { position: absolute; top: 70px; left: 50%; transform: translateX(-50%); width: 60%; display: none; }
        #boss-bar { width: 100%; height: 15px; background: #300; border: 2px solid #f00; }
        #boss-fill { width: 100%; height: 100%; background: #f00; transition: width 0.1s; }

        /* CROSSHAIR */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #0f0; font-size: 30px; }
        
        /* GAME SCREENS */
        #screen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 5000; pointer-events: auto; }
        #screen-img { width: 300px; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 0 50px #f00; }
        #play-btn { padding: 20px 50px; font-size: 30px; background: #f00; color: #fff; border: none; cursor: pointer; border-radius: 10px; font-family: inherit; }
        #play-btn:hover { background: #fff; color: #f00; }

        .joystick { position: absolute; bottom: 30px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; display: none; }
        #joy-left { left: 30px; }
        #joy-right { right: 30px; }

        /* ENHANCED MINIMAP */
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ff0000;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.4);
            pointer-events: none;
        }
        
        /* Health bar improvements */
        .health-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 220px;
        }
        
        .health-bar {
            width: 100%;
            height: 25px;
            background: rgba(255, 0, 0, 0.2);
            border: 3px solid #f00;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444, #ff0000);
            width: 100%;
            transition: width 0.1s;
            position: relative;
        }
        
        .health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: healthShine 2s infinite linear;
        }
        
        @keyframes healthShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .health-text {
            color: #ff0000;
            font-size: 18px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
            font-weight: bold;
        }
        
        /* Ammo counter */
        #ammo-ui {
            position: absolute;
            bottom: 80px;
            left: 20px;
            color: #ffcc00;
            font-size: 22px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #ffcc00;
            font-weight: bold;
        }
        
        /* Level indicator */
        #level-ui {
            position: absolute;
            top: 80px;
            right: 250px;
            color: #00ff00;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #00ff00;
            display: none;
        }
        
        /* Damage overlay */
        .damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 100;
            transition: background 0.2s;
        }
        
        /* Combo indicator */
        #combo-ui {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff9900;
            font-size: 28px;
            text-shadow: 0 0 15px rgba(255, 153, 0, 0.7);
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: bold;
        }
        
        /* Mission indicator */
        #mission-ui {
            position: absolute;
            top: 120px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 4px solid #00ff00;
            padding: 12px 20px;
            border-radius: 8px;
            max-width: 300px;
            display: none;
        }
        
        .mission-title {
            color: #00ff00;
            font-size: 16px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .mission-text {
            color: #ffffff;
            font-size: 14px;
        }
        
        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        #start-title {
            color: #ff0000;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }
        
        #start-btn {
            padding: 20px 50px;
            font-size: 30px;
            background: #f00;
            color: #fff;
            border: none;
            cursor: pointer;
            border-radius: 10px;
            font-family: inherit;
            margin: 20px;
        }
        
        #start-btn:hover {
            background: #fff;
            color: #f00;
        }
        
        .controls-info {
            color: #ffcc00;
            font-size: 16px;
            margin-top: 30px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffcc00;
            max-width: 500px;
            text-align: center;
        }
        
        /* Wave indicator */
        #wave-ui {
            position: absolute;
            top: 80px;
            left: 250px;
            color: #ff9900;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #ff9900;
            display: none;
        }
        
        /* Power-up indicator */
        #powerup-ui {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            display: none;
        }
    </style>
</head>
<body>

<div id="wrapper">
    <!-- START SCREEN -->
    <div id="start-screen">
        <h1 id="start-title">AGGRESSIVE PISTOL: ULTIMATE 3D</h1>
        <p style="color: #fff; font-size: 18px; max-width: 600px; text-align: center; margin-bottom: 30px;">
            ELIMINATE ALL ENEMIES. DEFEAT THE BOSS. SURVIVE AT ALL COSTS.
        </p>
        <button id="start-btn">START GAME</button>
        <div class="controls-info">
            <strong>CONTROLS:</strong><br>
            W/A/S/D - Move<br>
            Mouse - Look Around<br>
            Click - Shoot<br>
            Shift - Sprint<br>
            Click game area to lock mouse<br><br>
            <strong>POWER-UPS:</strong><br>
            Red Orbs - Health<br>
            Blue Orbs - Speed Boost<br>
            Yellow Orbs - Rapid Fire
        </div>
    </div>
    
    <canvas id="game"></canvas>
    <canvas id="minimap"></canvas>
    
    <div id="hud">
        <div class="health-container">
            <div class="health-text" id="health-text">HEALTH: 100</div>
            <div class="health-bar">
                <div class="health-fill" id="health-fill"></div>
            </div>
        </div>
        
        <div id="score-ui" class="stat">KILLS: 0</div>
        <div id="killfeed"></div>
        <div id="boss-container">
            <div style="text-align: center; color: #f00; font-weight: bold; margin-bottom: 5px; font-size: 20px;">AMNA THE AGGRESSOR</div>
            <div id="boss-bar"><div id="boss-fill"></div></div>
        </div>
        <div id="ammo-ui">AMMO: ∞</div>
        <div id="level-ui">LEVEL 1</div>
        <div id="wave-ui">WAVE: 1</div>
        <div id="powerup-ui"></div>
        <div id="combo-ui"></div>
        <div id="mission-ui">
            <div class="mission-title">OBJECTIVE</div>
            <div class="mission-text" id="mission-text">ELIMINATE ALL ENEMIES</div>
        </div>
        <div id="crosshair">+</div>
        <div class="damage-overlay" id="damage-overlay"></div>
    </div>

    <div id="screen-overlay">
        <img id="screen-img" src="./Dogswag.jpg" alt="Status">
        <h1 id="screen-msg">MAR GYE BC</h1>
        <button id="play-btn" onclick="restart()">REVIVE</button>
    </div>

    <div id="joy-left" class="joystick"></div>
    <div id="joy-right" class="joystick"></div>
</div>

<!-- THREE.JS FOR 3D MODELS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- GLTF LOADER - FIXED VERSION -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');
const startScreen = document.getElementById('start-screen');
const startBtn = document.getElementById('start-btn');

const WORLD_SIZE = 4000;
const FOV = Math.PI / 3;

// 3D SYSTEM
let scene3D, camera3D, renderer3D;
let zombieModel = null;
let grassModel = null; // NEW: Grass model
let modelReady = false;
let grassModelReady = false; // NEW: Grass model ready flag
const zombieCache = new Map();
const grassCache = new Map(); // NEW: Cache for grass
let modelLoadAttempted = false;
let grassLoadAttempted = false; // NEW: Grass load flag

// ASSETS - UPDATED WITH GRASS
const imgs = {
    enemy1: new Image(),
    enemy2: new Image(),
    boss: new Image(),
    ground: new Image(),
    grassTexture: new Image(), // NEW: Grass texture
    win: './win.jpg',
    lose: './Dogswag.jpg'
};

imgs.enemy1.src = './enemy1.png';
imgs.enemy2.src = './enemy2.png';
imgs.boss.src = './amna.png';
imgs.ground.src = './ground.png';
imgs.grassTexture.src = './grass.PNG'; // NEW: Load grass texture

// State
let player = { 
    x: 2000, 
    y: 2000, 
    angle: 0, 
    hp: 100, 
    maxHp: 100,
    kills: 0, 
    level: 1,
    bob: 0, 
    speed: 7,
    baseSpeed: 7,
    experience: 0,
    ammo: Infinity,
    fireRate: 150,
    baseFireRate: 150,
    powerUps: {
        speed: 0,
        rapidFire: 0
    }
};
let keys = {};
let sprites = [];
let grassPatches = []; // NEW: Array for grass patches
let particles = [];
let bullets = [];
let powerUps = [];
let gameActive = false;
let boss = null;
let lastFire = 0;
let muzzleFlash = 0;
let lastHitTime = 0;
let combo = 0;
let comboTimeout = null;
let wave = 1;
let enemiesPerWave = 5;
let enemiesKilledThisWave = 0;
let groundPattern = null;
let lastBossAttack = 0;
let bossAttackCooldown = 2000;

let missions = [
    { kills: 10, text: "ELIMINATE 10 ENEMIES", completed: false },
    { kills: 25, text: "ELIMINATE 25 ENEMIES", completed: false },
    { kills: 50, text: "ELIMINATE 50 ENEMIES", completed: false }
];
let currentMission = 0;

// FIXED INPUT HANDLING
window.addEventListener('keydown', e => {
    if (gameActive) {
        keys[e.key.toLowerCase()] = true;
        if (['w', 'a', 's', 'd', 'shift'].includes(e.key.toLowerCase())) {
            e.preventDefault();
        }
    }
});

window.addEventListener('keyup', e => {
    if (gameActive) {
        keys[e.key.toLowerCase()] = false;
    }
});

// Mouse handling
let mouseDown = false;
window.addEventListener('mousedown', (e) => {
    if (gameActive) {
        mouseDown = true;
        fire();
        e.preventDefault();
    }
});

window.addEventListener('mouseup', () => {
    mouseDown = false;
});

// Auto-fire when mouse is held
function handleAutoFire() {
    if (mouseDown && gameActive && Date.now() - lastFire > player.fireRate) {
        fire();
    }
}

// Pointer lock handling
function safePointerLock() {
    if (gameActive && canvas.requestPointerLock) {
        canvas.requestPointerLock().catch(err => {
            console.log("Pointer lock failed:", err);
        });
    }
}

canvas.addEventListener('click', () => { 
    if(gameActive) safePointerLock(); 
});

document.addEventListener('mousemove', e => {
    if (gameActive && document.pointerLockElement === canvas) {
        player.angle += e.movementX * 0.003;
    }
});

// Initialize 3D - UPDATED TO LOAD GRASS
function init3D() {
    try {
        const threeCanvas = document.createElement('canvas');
        threeCanvas.id = 'three-canvas';
        threeCanvas.style.display = 'none';
        document.body.appendChild(threeCanvas);
        
        scene3D = new THREE.Scene();
        scene3D.background = new THREE.Color(0x000000);
        
        // Better lighting for grass
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Brighter
        scene3D.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Stronger
        directionalLight.position.set(10, 20, 10); // Higher angle
        scene3D.add(directionalLight);
        
        camera3D = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera3D.position.set(0, 2, 5); // Adjusted for better view
        camera3D.lookAt(0, 1, 0);
        
        renderer3D = new THREE.WebGLRenderer({ 
            canvas: threeCanvas,
            alpha: true,
            antialias: true,
            preserveDrawingBuffer: true
        });
        renderer3D.setSize(256, 256);
        renderer3D.setPixelRatio(window.devicePixelRatio || 1);
        
        // Load both models
        setTimeout(loadGLBModels, 100);
        
    } catch (error) {
        console.error("❌ Error in init3D:", error);
        modelReady = false;
        grassModelReady = false;
    }
}

function loadGLBModels() {
    // Load zombie model
    if (!modelLoadAttempted) {
        modelLoadAttempted = true;
        const zombieLoader = new THREE.GLTFLoader();
        zombieLoader.load(
            './zombie.glb',
            function(gltf) {
                console.log("✅ Zombie model loaded!");
                zombieModel = gltf.scene;
                modelReady = true;
                
                zombieModel.scale.set(1, 1, 1);
                zombieModel.position.y = 0;
                scene3D.add(zombieModel);
                
                preRenderZombieFrames();
            },
            function(xhr) {
                console.log(`Zombie loading: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
            },
            function(error) {
                console.log("❌ Failed to load zombie model, using 2D fallback");
                modelReady = false;
            }
        );
    }
    
    // Load grass model
    if (!grassLoadAttempted) {
        grassLoadAttempted = true;
        const grassLoader = new THREE.GLTFLoader();
        grassLoader.load(
            './GRASS.glb',
            function(gltf) {
                console.log("✅ Grass model loaded!");
                grassModel = gltf.scene;
                grassModelReady = true;
                
                // Scale the grass appropriately
                grassModel.scale.set(5, 5, 5);
                grassModel.position.y = 0;
                
                // Create grass patches
                createGrassPatches();
                
                // Pre-render grass at different angles
                preRenderGrassFrames();
            },
            function(xhr) {
                console.log(`Grass loading: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
            },
            function(error) {
                console.log("❌ Failed to load grass model:", error);
                grassModelReady = false;
            }
        );
    }
}

function createGrassPatches() {
    if (!grassModelReady || !grassModel) return;
    
    grassPatches = [];
    
    // Create multiple grass patches across the map
    for(let i = 0; i < 100; i++) { // 100 grass patches
        const patch = {
            x: Math.random() * WORLD_SIZE,
            y: Math.random() * WORLD_SIZE,
            size: 100 + Math.random() * 100,
            rotation: Math.random() * Math.PI * 2,
            scale: 0.5 + Math.random() * 1.0
        };
        grassPatches.push(patch);
    }
}

function preRenderZombieFrames() {
    if (!modelReady || !zombieModel) return;
    
    for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const walkPhase = i / 8;
        
        zombieModel.rotation.y = angle;
        zombieModel.position.y = Math.sin(walkPhase * Math.PI * 2) * 0.1;
        
        zombieModel.traverse((child) => {
            if (child.isMesh) {
                if (child.name && child.name.toLowerCase().includes('arm')) {
                    child.rotation.x = Math.sin(walkPhase * Math.PI * 2) * 0.2;
                }
                if (child.name && child.name.toLowerCase().includes('leg')) {
                    child.rotation.x = Math.sin(walkPhase * Math.PI * 2 + Math.PI) * 0.2;
                }
            }
        });
        
        renderer3D.render(scene3D, camera3D);
        
        const key = `zombie_angle_${i}_walk_${i}`;
        const cachedCanvas = document.createElement('canvas');
        cachedCanvas.width = 256;
        cachedCanvas.height = 256;
        const cachedCtx = cachedCanvas.getContext('2d');
        cachedCtx.drawImage(renderer3D.domElement, 0, 0);
        
        zombieCache.set(key, cachedCanvas);
    }
}

// NEW: Pre-render grass frames
function preRenderGrassFrames() {
    if (!grassModelReady || !grassModel) return;
    
    // Render grass at 4 different rotations
    for(let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        
        grassModel.rotation.y = angle;
        grassModel.position.y = 0;
        
        renderer3D.render(scene3D, camera3D);
        
        const key = `grass_angle_${i}`;
        const cachedCanvas = document.createElement('canvas');
        cachedCanvas.width = 256;
        cachedCanvas.height = 256;
        const cachedCtx = cachedCanvas.getContext('2d');
        cachedCtx.drawImage(renderer3D.domElement, 0, 0);
        
        grassCache.set(key, cachedCanvas);
    }
}

function renderZombie3D(zombie) {
    if (!modelReady || !zombieModel) return null;
    
    const angleIndex = Math.floor((zombie.angle / (Math.PI * 2)) * 8) % 8;
    const walkIndex = Math.floor((zombie.walkPhase % 1) * 4) % 4;
    const key = `zombie_angle_${angleIndex}_walk_${walkIndex}`;
    
    if (zombieCache.has(key)) {
        return zombieCache.get(key);
    }
    
    zombieModel.rotation.y = zombie.angle;
    zombieModel.position.y = Math.sin(zombie.walkPhase * Math.PI * 2) * 0.1;
    
    zombieModel.traverse((child) => {
        if (child.isMesh) {
            if (child.name && child.name.toLowerCase().includes('arm')) {
                child.rotation.x = Math.sin(zombie.walkPhase * Math.PI * 2) * 0.3;
            }
            if (child.name && child.name.toLowerCase().includes('leg')) {
                child.rotation.x = Math.sin(zombie.walkPhase * Math.PI * 2 + Math.PI) * 0.3;
            }
        }
    });
    
    renderer3D.render(scene3D, camera3D);
    
    const cachedCanvas = document.createElement('canvas');
    cachedCanvas.width = 256;
    cachedCanvas.height = 256;
    const cachedCtx = cachedCanvas.getContext('2d');
    cachedCtx.drawImage(renderer3D.domElement, 0, 0);
    
    zombieCache.set(key, cachedCanvas);
    return cachedCanvas;
}

// NEW: Render grass 3D
function renderGrass3D(patch) {
    if (!grassModelReady || !grassModel) return null;
    
    // Use angle based on patch position for variation
    const angleIndex = Math.floor((patch.rotation / (Math.PI * 2)) * 4) % 4;
    const key = `grass_angle_${angleIndex}`;
    
    if (grassCache.has(key)) {
        return grassCache.get(key);
    }
    
    // Set up grass model for rendering
    grassModel.rotation.y = patch.rotation;
    grassModel.position.y = 0;
    grassModel.scale.set(patch.scale, patch.scale, patch.scale);
    
    renderer3D.render(scene3D, camera3D);
    
    const cachedCanvas = document.createElement('canvas');
    cachedCanvas.width = 256;
    cachedCanvas.height = 256;
    const cachedCtx = cachedCanvas.getContext('2d');
    cachedCtx.drawImage(renderer3D.domElement, 0, 0);
    
    grassCache.set(key, cachedCanvas);
    return cachedCanvas;
}

function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    minimapCanvas.width = 200;
    minimapCanvas.height = 200;
    
    setTimeout(init3D, 100);
    
    generateEnvironment();
    
    startBtn.addEventListener('click', startGame);
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !gameActive) {
            startGame();
        }
    });
    
    // Initialize ground pattern
    imgs.ground.onload = function() {
        groundPattern = ctx.createPattern(imgs.ground, 'repeat');
    };
}

function startGame() {
    startScreen.style.display = 'none';
    gameActive = true;
    canvas.style.display = 'block';
    
    document.getElementById('mission-ui').style.display = 'block';
    document.getElementById('mission-text').textContent = missions[currentMission].text;
    
    setTimeout(() => {
        document.getElementById('mission-ui').style.display = 'none';
    }, 5000);
    
    // Show wave indicator
    document.getElementById('wave-ui').style.display = 'block';
    document.getElementById('wave-ui').textContent = `WAVE: ${wave}`;
    
    loop();
}

function generateEnvironment() {
    sprites = [];
    powerUps = [];
    
    // Add trees/obstacles
    for(let i=0; i<30; i++) { // Reduced trees to make room for grass
        sprites.push({
            x: Math.random() * WORLD_SIZE,
            y: Math.random() * WORLD_SIZE,
            size: 200 + Math.random() * 200,
            type: 'obstacle',
            trunkColor: '#4d2600',
            leafColor: `rgb(0, ${80 + Math.random()*60}, 0)`
        });
    }
    
    // Add rocks
    for(let i=0; i<20; i++) { // Reduced rocks
        sprites.push({
            x: Math.random() * WORLD_SIZE,
            y: Math.random() * WORLD_SIZE,
            size: 100 + Math.random() * 100,
            type: 'rock',
            color: '#555555'
        });
    }
    
    // Spawn initial wave
    for(let i=0; i<enemiesPerWave; i++) {
        spawnEnemy();
    }
}

function spawnEnemy() {
    if (boss) return;
    
    const ang = Math.random() * Math.PI * 2;
    const distance = 600 + Math.random() * 400;
    sprites.push({
        x: player.x + Math.cos(ang) * distance,
        y: player.y + Math.sin(ang) * distance,
        size: 180,
        type: 'zombie3d', 
        hp: 1 + Math.floor(wave/3),
        speed: 3 + (player.kills * 0.05) + (wave * 0.1),
        angle: Math.random() * Math.PI * 2,
        walkPhase: Math.random() * Math.PI * 2,
        walkSpeed: 0.05 + Math.random() * 0.03,
        bobOffset: 0,
        lastRender: null
    });
}

function spawnPowerUp(x, y, type) {
    let color, effect;
    switch(type) {
        case 'health':
            color = '#ff0000';
            effect = 'HEALTH+';
            break;
        case 'speed':
            color = '#00ffff';
            effect = 'SPEED BOOST';
            break;
        case 'rapid':
            color = '#ffff00';
            effect = 'RAPID FIRE';
            break;
    }
    
    powerUps.push({
        x, y,
        size: 60,
        type: type,
        color: color,
        effect: effect,
        rotation: 0,
        bob: 0
    });
}

// FIXED BOSS PROJECTILE FUNCTION
function spawnBossProjectile(boss) {
    const now = Date.now();
    if (now - lastBossAttack < bossAttackCooldown) return;
    lastBossAttack = now;
    
    for(let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        bullets.push({
            x: boss.x, y: boss.y,
            vx: Math.cos(angle) * 12,
            vy: Math.sin(angle) * 12,
            life: 90,
            color: '#ff00ff',
            isBossProjectile: true
        });
    }
}

function triggerBoss() {
    boss = { 
        x: player.x + 500, 
        y: player.y + 500, 
        size: 500, 
        type: 'boss', 
        hp: 150 + (wave * 25),
        maxHp: 150 + (wave * 25),
        angle: 0,
        attackTimer: 0,
        attackPattern: 0,
        invulnerable: false,
        invulTimer: 0,
        lastAttackTime: 0
    };
    sprites.push(boss);
    document.getElementById('boss-container').style.display = 'block';
    
    sprites = sprites.filter(s => s.type !== 'zombie3d');
    
    document.getElementById('mission-ui').style.display = 'block';
    document.getElementById('mission-text').textContent = "DEFEAT THE BOSS!";
    setTimeout(() => {
        document.getElementById('mission-ui').style.display = 'none';
    }, 5000);
}

function fire() {
    if(!gameActive || Date.now() - lastFire < player.fireRate) return;
    lastFire = Date.now();
    muzzleFlash = 5;
    
    const spread = (keys['shift'] ? 0.05 : 0.02);
    const angle = player.angle + (Math.random() - 0.5) * spread;
    
    bullets.push({
        x: player.x, y: player.y,
        vx: Math.cos(angle) * 30, vy: Math.sin(angle) * 30,
        life: 60,
        trail: []
    });
}

function showDamage() {
    document.getElementById('damage-overlay').style.background = 'rgba(255, 0, 0, 0.5)';
    lastHitTime = Date.now();
}

function update() {
    if(!gameActive) return;

    handleAutoFire();

    // Update player power-ups
    if (player.powerUps.speed > 0) {
        player.powerUps.speed--;
        if (player.powerUps.speed === 0) {
            player.speed = player.baseSpeed;
            document.getElementById('powerup-ui').style.display = 'none';
        }
    }
    
    if (player.powerUps.rapidFire > 0) {
        player.powerUps.rapidFire--;
        if (player.powerUps.rapidFire === 0) {
            player.fireRate = player.baseFireRate;
            document.getElementById('powerup-ui').style.display = 'none';
        }
    }

    let sprintMultiplier = keys['shift'] ? 1.8 : 1;
    let mx = 0, my = 0;
    if(keys['w']) { mx += Math.cos(player.angle); my += Math.sin(player.angle); }
    if(keys['s']) { mx -= Math.cos(player.angle); my -= Math.sin(player.angle); }
    if(keys['a']) { mx += Math.sin(player.angle); my -= Math.cos(player.angle); }
    if(keys['d']) { mx -= Math.sin(player.angle); my += Math.cos(player.angle); }

    if(mx !== 0 || my !== 0) {
        player.x += mx * player.speed * sprintMultiplier;
        player.y += my * player.speed * sprintMultiplier;
        player.bob += 0.15 * sprintMultiplier;
    }

    // Keep player in bounds
    const borderBuffer = 50;
    player.x = Math.max(borderBuffer, Math.min(WORLD_SIZE - borderBuffer, player.x));
    player.y = Math.max(borderBuffer, Math.min(WORLD_SIZE - borderBuffer, player.y));

    // UPDATE BULLETS
    for(let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx; 
        b.y += b.vy; 
        b.life--;
        
        // Add trail point
        if (b.trail) {
            b.trail.push({x: b.x, y: b.y});
            if (b.trail.length > 3) b.trail.shift();
        }
        
        if(b.life <= 0) {
            bullets.splice(i,1);
            continue;
        }
        
        // Check bullet collisions
        for(let j = sprites.length - 1; j >= 0; j--) {
            let s = sprites[j];
            if(s.type === 'zombie3d' || s.type === 'boss') {
                if (s.type === 'boss' && s.invulnerable) continue;
                
                let d = Math.sqrt((b.x - s.x)**2 + (b.y - s.y)**2);
                if(d < s.size/3) {
                    s.hp--;
                    createExplosion(s.x, s.y, b.isBossProjectile ? '#ff00ff' : '#f00');
                    bullets.splice(i, 1);
                    if(s.hp <= 0) {
                        killSprite(s);
                    }
                    break;
                }
            }
        }
    }

    // Update particles
    for(let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx; 
        p.y += p.vy; 
        p.life -= 0.05;
        if(p.life <= 0) particles.splice(i,1);
        
        if (particles.length > 200) {
            particles.splice(0, particles.length - 200);
        }
    }

    // Update power-ups
    for(let i = powerUps.length - 1; i >= 0; i--) {
        let p = powerUps[i];
        p.rotation += 0.05;
        p.bob += 0.1;
        
        let dx = p.x - player.x;
        let dy = p.y - player.y;
        let d = Math.sqrt(dx*dx + dy*dy);
        
        if (d < 50) {
            switch(p.type) {
                case 'health':
                    player.hp = Math.min(player.maxHp, player.hp + 30);
                    document.getElementById('powerup-ui').style.display = 'block';
                    document.getElementById('powerup-ui').textContent = 'HEALTH +30';
                    setTimeout(() => {
                        document.getElementById('powerup-ui').style.display = 'none';
                    }, 2000);
                    break;
                case 'speed':
                    player.speed = player.baseSpeed * 1.5;
                    player.powerUps.speed = 600;
                    document.getElementById('powerup-ui').style.display = 'block';
                    document.getElementById('powerup-ui').textContent = 'SPEED BOOST';
                    break;
                case 'rapid':
                    player.fireRate = player.baseFireRate / 2;
                    player.powerUps.rapidFire = 450;
                    document.getElementById('powerup-ui').style.display = 'block';
                    document.getElementById('powerup-ui').textContent = 'RAPID FIRE';
                    break;
            }
            
            createExplosion(p.x, p.y, p.color);
            powerUps.splice(i, 1);
        }
    }

    // Update sprites
    sprites.forEach(s => {
        if(s.type === 'zombie3d') {
            let dx = player.x - s.x, dy = player.y - s.y;
            let d = Math.sqrt(dx*dx + dy*dy);
            if(d > 0) {
                s.x += (dx/d) * s.speed; 
                s.y += (dy/d) * s.speed;
            }
            
            s.angle = Math.atan2(dy, dx);
            s.walkPhase += s.walkSpeed;
            s.bobOffset = Math.sin(s.walkPhase * 2) * 3;
            
            if(d < 50) {
                player.hp -= 0.5 + (wave * 0.1);
                showDamage();
                if(player.hp <= 0) endGame(false);
            }
        }
        if(s.type === 'boss') {
            if (s.invulnerable) {
                s.invulTimer--;
                if (s.invulTimer <= 0) {
                    s.invulnerable = false;
                }
            }
            
            s.angle += 0.02; 
            s.x += Math.cos(s.angle) * 6; 
            s.y += Math.sin(s.angle) * 6;
            
            const now = Date.now();
            if (!s.invulnerable && now - s.lastAttackTime > 1500) {
                s.lastAttackTime = now;
                
                spawnBossProjectile(s);
                
                if (Math.random() < 0.3) {
                    s.invulnerable = true;
                    s.invulTimer = 60;
                    createExplosion(s.x, s.y, '#00ffff');
                }
            }
        }
    });

    // Spawn new enemies for current wave
    const currentEnemies = sprites.filter(s => s.type === 'zombie3d').length;
    if(!boss && currentEnemies < enemiesPerWave && Math.random() < 0.02) {
        spawnEnemy();
    }
    
    // Check if wave is complete
    if (!boss && enemiesKilledThisWave >= enemiesPerWave) {
        wave++;
        enemiesKilledThisWave = 0;
        enemiesPerWave = 5 + Math.floor(wave * 1.5);
        
        document.getElementById('wave-ui').style.display = 'block';
        document.getElementById('wave-ui').textContent = `WAVE: ${wave}`;
        setTimeout(() => {
            document.getElementById('wave-ui').style.display = 'none';
        }, 3000);
        
        if (wave % 3 === 0) {
            const types = ['health', 'speed', 'rapid'];
            const type = types[Math.floor(Math.random() * types.length)];
            spawnPowerUp(player.x + 200, player.y + 200, type);
        }
        
        for(let i=0; i<enemiesPerWave; i++) {
            spawnEnemy();
        }
    }
    
    // Update UI
    const healthPercent = Math.max(0, player.hp / player.maxHp * 100);
    document.getElementById('health-fill').style.width = healthPercent + '%';
    document.getElementById('health-text').innerText = `HEALTH: ${Math.floor(player.hp)}`;
    
    document.getElementById('score-ui').innerText = `KILLS: ${player.kills}`;
    if(boss) document.getElementById('boss-fill').style.width = (boss.hp/boss.maxHp)*100 + '%';
    
    // Damage overlay
    if (Date.now() - lastHitTime < 200) {
        document.getElementById('damage-overlay').style.background = 'rgba(255, 0, 0, 0.5)';
    } else {
        document.getElementById('damage-overlay').style.background = 'rgba(255, 0, 0, 0)';
    }
    
    // Check for boss spawn at 30 kills
    if(player.kills >= 30 && !boss) {
        triggerBoss();
    }
    
    // Check mission progress
    if (currentMission < missions.length && player.kills >= missions[currentMission].kills) {
        missions[currentMission].completed = true;
        currentMission++;
        if (currentMission < missions.length) {
            document.getElementById('mission-ui').style.display = 'block';
            document.getElementById('mission-text').textContent = missions[currentMission].text;
            setTimeout(() => {
                document.getElementById('mission-ui').style.display = 'none';
            }, 5000);
        }
    }
    
    // Level up
    if (player.kills >= player.level * 15) {
        player.level++;
        player.maxHp += 20;
        player.baseSpeed += 0.5;
        player.hp = Math.min(player.maxHp, player.hp + 30);
        document.getElementById('level-ui').style.display = 'block';
        document.getElementById('level-ui').textContent = `LEVEL ${player.level}`;
        
        setTimeout(() => {
            document.getElementById('level-ui').style.display = 'none';
        }, 3000);
    }
}

function createExplosion(x, y, color) {
    for(let i=0; i<6; i++) {
        particles.push({ 
            x, y, 
            vx: (Math.random()-0.5)*8,
            vy: (Math.random()-0.5)*8, 
            life: 0.8,
            color 
        });
    }
}

function killSprite(s) {
    let idx = sprites.indexOf(s);
    if(idx > -1) {
        sprites.splice(idx, 1);
        
        if(s.type === 'zombie3d') {
            player.kills++;
            enemiesKilledThisWave++;
            
            clearTimeout(comboTimeout);
            combo++;
            comboTimeout = setTimeout(() => {
                if (combo > 3) {
                    document.getElementById('combo-ui').textContent = `${combo} KILL COMBO!`;
                    document.getElementById('combo-ui').style.opacity = '1';
                    setTimeout(() => {
                        document.getElementById('combo-ui').style.opacity = '0';
                    }, 2000);
                    
                    if (combo >= 5 && Math.random() < 0.3) {
                        const types = ['health', 'speed', 'rapid'];
                        const type = types[Math.floor(Math.random() * types.length)];
                        spawnPowerUp(s.x, s.y, type);
                    }
                }
                combo = 0;
            }, 3000);
            
            document.getElementById('score-ui').innerText = `KILLS: ${player.kills}`;
            if(player.kills === 30) triggerBoss();
        } else if(s.type === 'boss') {
            endGame(true);
        }
    }
}

// FALLBACK 2D ZOMBIE
function drawFallbackZombie(zombie, screenX, yPos, size) {
    ctx.save();
    ctx.translate(screenX, yPos + zombie.bobOffset);
    
    ctx.fillStyle = '#2a5c2a';
    ctx.fillRect(-size/3, -size*0.8, size*0.66, size*0.8);
    
    ctx.fillStyle = '#1a3a1a';
    ctx.beginPath();
    ctx.arc(0, -size, size/3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(-size/6, -size - size/12, size/10, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(size/6, -size - size/12, size/10, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    ctx.strokeStyle = '#1a3a1a';
    ctx.lineWidth = size/8;
    
    const legAngle = Math.sin(zombie.walkPhase * 2) * 0.3;
    
    ctx.save();
    ctx.translate(-size/6, -size*0.1);
    ctx.rotate(legAngle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-size/8, size/2);
    ctx.stroke();
    ctx.restore();
    
    ctx.save();
    ctx.translate(size/6, -size*0.1);
    ctx.rotate(-legAngle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(size/8, size/2);
    ctx.stroke();
    ctx.restore();
    
    ctx.restore();
}

function drawZombie3D(zombie, screenX, yPos, size) {
    const zombieCanvas = renderZombie3D(zombie);
    if (zombieCanvas) {
        ctx.save();
        ctx.translate(screenX, yPos + zombie.bobOffset);
        
        ctx.drawImage(zombieCanvas, -size/2, -size, size, size);
        
        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(0, -size * 0.6, size/8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.restore();
        return;
    }
    
    drawFallbackZombie(zombie, screenX, yPos, size);
}

// NEW: Draw 3D grass
function drawGrass3D(patch, screenX, yPos, size) {
    const grassCanvas = renderGrass3D(patch);
    if (grassCanvas) {
        ctx.save();
        ctx.translate(screenX, yPos);
        
        // Draw grass with transparency
        ctx.globalAlpha = 0.8;
        ctx.drawImage(grassCanvas, -size/2, -size, size, size);
        ctx.globalAlpha = 1.0;
        
        ctx.restore();
        return true;
    }
    return false;
}

// MINIMAP FUNCTION
function drawMinimap() {
    let size = minimapCanvas.width;
    let center = size / 2;
    
    let zoomFactor = 0.3;
    let scale = size / (WORLD_SIZE * zoomFactor);
    
    minimapCtx.clearRect(0, 0, size, size);
    
    let gradient = minimapCtx.createRadialGradient(center, center, 0, center, center, center);
    gradient.addColorStop(0, 'rgba(0, 20, 0, 0.9)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');
    minimapCtx.fillStyle = gradient;
    minimapCtx.beginPath();
    minimapCtx.arc(center, center, center - 2, 0, Math.PI * 2);
    minimapCtx.fill();
    
    minimapCtx.strokeStyle = 'rgba(0, 255, 0, 0.15)';
    minimapCtx.lineWidth = 1;
    
    for (let r = 25; r < center; r += 25) {
        minimapCtx.beginPath();
        minimapCtx.arc(center, center, r, 0, Math.PI * 2);
        minimapCtx.stroke();
    }
    
    for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
        minimapCtx.beginPath();
        minimapCtx.moveTo(center, center);
        minimapCtx.lineTo(center + Math.cos(a) * center, center + Math.sin(a) * center);
        minimapCtx.stroke();
    }
    
    minimapCtx.fillStyle = '#ff0000';
    minimapCtx.font = 'bold 11px Arial';
    minimapCtx.textAlign = 'center';
    minimapCtx.textBaseline = 'middle';
    minimapCtx.fillText('N', center, 15);
    minimapCtx.fillText('E', size - 15, center);
    minimapCtx.fillText('S', center, size - 15);
    minimapCtx.fillText('W', 15, center);
    
    const visibleRadius = (size / scale) / 2;
    
    sprites.forEach(s => {
        let worldX = s.x;
        let worldY = s.y;
        let symbol = '';
        let color = '';
        let symbolSize = 8;
        
        switch(s.type) {
            case 'obstacle':
                symbol = '▲';
                color = '#00ff00';
                symbolSize = 6;
                break;
            case 'rock':
                symbol = '■';
                color = '#888888';
                symbolSize = 5;
                break;
            case 'zombie3d':
                symbol = '●';
                color = '#ff0000';
                symbolSize = 8;
                break;
            case 'boss':
                symbol = '★';
                color = '#ffff00';
                symbolSize = 12;
                break;
        }
        
        if (symbol) {
            let dx = worldX - player.x;
            let dy = worldY - player.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < visibleRadius) {
                let minimapX = center + (dx * scale);
                let minimapY = center + (dy * scale);
                
                let mapDx = minimapX - center;
                let mapDy = minimapY - center;
                let mapDistance = Math.sqrt(mapDx * mapDx + mapDy * mapDy);
                
                if (mapDistance < center - 5) {
                    minimapCtx.fillStyle = color;
                    minimapCtx.font = `bold ${symbolSize}px Arial`;
                    minimapCtx.textAlign = 'center';
                    minimapCtx.textBaseline = 'middle';
                    minimapCtx.fillText(symbol, minimapX, minimapY);
                    
                    if (s.type === 'boss') {
                        minimapCtx.shadowColor = color;
                        minimapCtx.shadowBlur = 10;
                        minimapCtx.fillText(symbol, minimapX, minimapY);
                        minimapCtx.shadowBlur = 0;
                    }
                }
            }
        }
    });
    
    // Draw power-ups on minimap
    powerUps.forEach(p => {
        let dx = p.x - player.x;
        let dy = p.y - player.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < visibleRadius) {
            let minimapX = center + (dx * scale);
            let minimapY = center + (dy * scale);
            
            let mapDx = minimapX - center;
            let mapDy = minimapY - center;
            let mapDistance = Math.sqrt(mapDx * mapDx + mapDy * mapDy);
            
            if (mapDistance < center - 5) {
                minimapCtx.fillStyle = p.color;
                minimapCtx.font = 'bold 10px Arial';
                minimapCtx.textAlign = 'center';
                minimapCtx.textBaseline = 'middle';
                minimapCtx.fillText('⬤', minimapX, minimapY);
            }
        }
    });
    
    minimapCtx.fillStyle = '#00ffff';
    minimapCtx.beginPath();
    minimapCtx.arc(center, center, 5, 0, Math.PI * 2);
    minimapCtx.fill();
    
    minimapCtx.strokeStyle = '#00ffff';
    minimapCtx.lineWidth = 3;
    minimapCtx.beginPath();
    minimapCtx.moveTo(center, center);
    minimapCtx.lineTo(
        center + Math.cos(player.angle) * 20,
        center + Math.sin(player.angle) * 20
    );
    minimapCtx.stroke();
    
    minimapCtx.fillStyle = 'rgba(0, 255, 255, 0.1)';
    minimapCtx.beginPath();
    minimapCtx.moveTo(center, center);
    minimapCtx.arc(center, center, 80, player.angle - FOV/2, player.angle + FOV/2);
    minimapCtx.closePath();
    minimapCtx.fill();
    
    minimapCtx.strokeStyle = '#ff0000';
    minimapCtx.lineWidth = 3;
    minimapCtx.beginPath();
    minimapCtx.arc(center, center, center - 1, 0, Math.PI * 2);
    minimapCtx.stroke();
    
    minimapCtx.fillStyle = '#ff0000';
    minimapCtx.font = 'bold 10px Arial';
    minimapCtx.textAlign = 'left';
    minimapCtx.textBaseline = 'top';
    minimapCtx.fillText('ZOOM 3X', 8, 8);
}

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);
    let horizon = canvas.height / 2 + Math.sin(player.bob) * 10;
    
    // DRAW GROUND WITH GRASS TEXTURE
    if (groundPattern) {
        ctx.fillStyle = groundPattern;
        ctx.fillRect(0, horizon, canvas.width, canvas.height - horizon);
        
        // Add green tint for grass
        const grassTint = ctx.createLinearGradient(0, horizon, 0, canvas.height);
        grassTint.addColorStop(0, 'rgba(0, 100, 0, 0.3)');
        grassTint.addColorStop(1, 'rgba(0, 60, 0, 0.5)');
        ctx.fillStyle = grassTint;
        ctx.fillRect(0, horizon, canvas.width, canvas.height - horizon);
    } else {
        // Fallback grass ground
        ctx.fillStyle = '#0a3a0a'; // Darker green for grass
        ctx.fillRect(0, horizon, canvas.width, canvas.height - horizon);
    }
    
    // DRAW SKY
    ctx.fillStyle = '#050505'; 
    ctx.fillRect(0,0, canvas.width, horizon);
    
    // Add some stars
    ctx.fillStyle = '#ffffff';
    for(let i = 0; i < 30; i++) {
        const x = (i * 37) % canvas.width;
        const y = (i * 23) % horizon;
        const size = 1 + Math.sin(Date.now() * 0.001 + i) * 0.5;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }

    // Create combined renderable array
    let renderable = [...sprites, ...bullets, ...powerUps, ...particles];
    
    // Calculate distances and angles for all objects
    renderable.forEach(s => {
        let dx = s.x - player.x, dy = s.y - player.y;
        s.dist = Math.sqrt(dx*dx + dy*dy);
        let angleToSprite = Math.atan2(dy, dx) - player.angle;
        while(angleToSprite < -Math.PI) angleToSprite += Math.PI * 2;
        while(angleToSprite > Math.PI) angleToSprite -= Math.PI * 2;
        s.angleDiff = angleToSprite;
    });

    // Sort by distance
    renderable.sort((a,b) => b.dist - a.dist);

    // Draw 3D grass patches first (so they appear under other objects)
    grassPatches.forEach(patch => {
        let dx = patch.x - player.x, dy = patch.y - player.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let angleToPatch = Math.atan2(dy, dx) - player.angle;
        
        while(angleToPatch < -Math.PI) angleToPatch += Math.PI * 2;
        while(angleToPatch > Math.PI) angleToPatch -= Math.PI * 2;
        
        if(Math.abs(angleToPatch) > FOV || dist < 5) return;
        
        let screenX = (0.5 * (angleToPatch / (FOV/2)) + 0.5) * canvas.width;
        let scale = 500 / dist;
        let size = patch.size * scale;
        let yPos = horizon + (scale * 10); // Grass sits lower on ground
        
        // Draw 3D grass
        if (!drawGrass3D(patch, screenX, yPos, size)) {
            // Fallback 2D grass
            ctx.save();
            ctx.translate(screenX, yPos);
            
            // Simple green grass patch
            ctx.fillStyle = '#00aa00';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(0, 0, size/4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            
            // Grass blades
            ctx.strokeStyle = '#006600';
            ctx.lineWidth = size/20;
            for(let i = 0; i < 5; i++) {
                const angle = (i/5) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(
                    Math.cos(angle) * size/2,
                    Math.sin(angle) * size/2 - size/4
                );
                ctx.stroke();
            }
            ctx.restore();
        }
    });

    // Draw all other objects
    renderable.forEach(s => {
        if(Math.abs(s.angleDiff) > FOV || s.dist < 5) return;
        let screenX = (0.5 * (s.angleDiff / (FOV/2)) + 0.5) * canvas.width;
        let scale = 500 / s.dist;
        let size = (s.size || 20) * scale;
        let yPos = horizon + (scale * 20);

        if(s.type === 'zombie3d') {
            drawZombie3D(s, screenX, yPos, size);
        }
        else if(s.type === 'boss') {
            ctx.save();
            ctx.translate(screenX, yPos);
            
            if (s.invulnerable) {
                const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                ctx.globalAlpha = pulse;
            }
            
            if (imgs.boss.complete) {
                ctx.drawImage(imgs.boss, -size/2, -size, size, size);
            } else {
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(0, -size/2, size/3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (s.hp < s.maxHp) {
                const barWidth = size;
                const barHeight = size/20;
                ctx.fillStyle = '#300';
                ctx.fillRect(-barWidth/2, -size*1.1, barWidth, barHeight);
                ctx.fillStyle = '#f00';
                ctx.fillRect(-barWidth/2, -size*1.1, barWidth * (s.hp/s.maxHp), barHeight);
            }
            
            ctx.restore();
        }
        else if(s.type === 'obstacle') {
            ctx.save();
            ctx.translate(screenX, yPos);
            ctx.fillStyle = s.trunkColor;
            ctx.fillRect(-size*0.1, -size*0.4, size*0.2, size*0.4);
            ctx.fillStyle = s.leafColor;
            ctx.beginPath();
            ctx.moveTo(0, -size); ctx.lineTo(-size*0.4, -size*0.3); ctx.lineTo(size*0.4, -size*0.3);
            ctx.fill();
            ctx.restore();
        }
        else if(s.type === 'rock') {
            ctx.save();
            ctx.translate(screenX, yPos);
            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.arc(0, 0, size/3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            ctx.arc(-size/8, -size/8, size/10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(size/8, size/8, size/12, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        else if(s.type) { // Power-ups
            ctx.save();
            ctx.translate(screenX, yPos + Math.sin(s.bob) * 10);
            ctx.rotate(s.rotation);
            
            ctx.shadowColor = s.color;
            ctx.shadowBlur = 20;
            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.arc(0, 0, size/3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, 0, size/6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000000';
            ctx.font = `bold ${size/6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            switch(s.type) {
                case 'health': ctx.fillText('+', 0, 0); break;
                case 'speed': ctx.fillText('⚡', 0, 0); break;
                case 'rapid': ctx.fillText('⚡', 0, 0); break;
            }
            ctx.restore();
        }
        else if(s.vx) {
            ctx.save();
            ctx.translate(screenX, yPos);
            
            if (s.trail && s.trail.length > 1) {
                ctx.strokeStyle = s.color || 'yellow';
                ctx.lineWidth = scale * 2;
                ctx.beginPath();
                if (s.trail.length >= 2) {
                    ctx.moveTo(s.trail[0].x - player.x, s.trail[0].y - player.y);
                    ctx.lineTo(s.trail[s.trail.length-1].x - player.x, s.trail[s.trail.length-1].y - player.y);
                }
                ctx.stroke();
            }
            
            ctx.fillStyle = s.color || 'yellow';
            let pSize = (s.life * 5) * scale;
            ctx.beginPath();
            ctx.arc(0, 0, pSize/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    });

    // Muzzle flash
    if(muzzleFlash > 0) {
        const flashSize = 100 + Math.sin(Date.now() * 0.05) * 20;
        ctx.fillStyle = `rgba(255, 255, 0, ${muzzleFlash/5})`;
        ctx.beginPath(); 
        ctx.arc(canvas.width/2, canvas.height/2 + 50, flashSize, 0, Math.PI*2); 
        ctx.fill();
        
        ctx.fillStyle = `rgba(255, 100, 0, ${muzzleFlash/8})`;
        ctx.beginPath();
        ctx.ellipse(canvas.width/2 + Math.cos(player.angle) * 60, 
                   canvas.height/2 + 50 + Math.sin(player.angle) * 60,
                   flashSize/3, flashSize, player.angle, 0, Math.PI * 2);
        ctx.fill();
        muzzleFlash--;
    }

    // Blood splatter
    if (Date.now() - lastHitTime < 300) {
        const intensity = 1 - ((Date.now() - lastHitTime) / 300);
        ctx.fillStyle = `rgba(255, 0, 0, ${intensity * 0.3})`;
        for(let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 50 + Math.random() * 100;
            const size = 10 + Math.random() * 20;
            ctx.beginPath();
            ctx.arc(canvas.width/2 + Math.cos(angle) * dist,
                   canvas.height/2 + Math.sin(angle) * dist,
                   size * intensity, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawMinimap();
}

function endGame(won) {
    gameActive = false; 
    if (document.pointerLockElement) {
        document.exitPointerLock();
    }
    const overlay = document.getElementById('screen-overlay');
    overlay.style.display = 'flex';
    document.getElementById('screen-img').src = won ? imgs.win : imgs.lose;
    document.getElementById('screen-msg').innerText = won ? "VICTORY BC!" : "MAR GYE BC OUCHHH";
}

function restart() { 
    location.reload(); 
}

function loop() { 
    if (gameActive) {
        update(); 
        draw(); 
    }
    requestAnimationFrame(loop); 
}

window.addEventListener('load', init);
window.addEventListener('resize', () => { 
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight; 
});

console.log("🎮 AGGRESSIVE PISTOL: ULTIMATE 3D WITH GRASS!");
</script>
</body>
</html>
